<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives: 2014/8 | Cubika&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Cubika's Blog">
<meta property="og:url" content="http://yoursite.com/archives/2014/08/">
<meta property="og:site_name" content="Cubika's Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cubika's Blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Cubika&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Cubika&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一元复始太虚生,破开混沌分两仪</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-【译】：为什么Web-Components还不适合于生产环境" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/11/【译】：为什么Web-Components还不适合于生产环境/" class="article-date">
  <time datetime="2014-08-11T11:05:06.000Z" itemprop="datePublished">8月 11 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/11/【译】：为什么Web-Components还不适合于生产环境/">【译】：为什么Web Components还不适合于生产环境</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文地址：<a href="http://developer.telerik.com/featured/web-components-arent-ready-production-yet/" target="_blank" rel="external">http://developer.telerik.com/featured/web-components-arent-ready-production-yet/</a><br>Web Components已经成为新的话题热点，由于Chrome 36已经完全实现了web components，我们终于可以有一个稳定的版本去使用它。虽然web components非常令人激动，但是这并不意味着它已经适合生产环境了。</p>
<h2 id="浏览器支持">浏览器支持</h2>
<p>最显著的问题就是浏览器支持，虽然chrome 36上已经完全实现了，但是在Firefox上仅仅是部分实现，IE和Safari上压根就没有实现。因为浏览器支持是一个非常漫长的过程，因此，我们会在很长的一段时间内不得不依靠polyfill来在其他浏览器上使用。<br>好消息是Polymer团队已经维护了一整套这种polyfill脚本，并取名为<em>Platform</em>。虽然官网上说，你所做的仅仅就是引入一个<code>platform.js</code>，但是事实上没有你想的那么简单。</p>
<h2 id="所有的polyfill实现起来难度不同">所有的polyfill实现起来难度不同</h2>
<p>虽然polyfill都叫做polyfill，但是它们的复杂程度却不尽相同。比如，有些polyfill仅仅是一些语法糖的实现，可以依赖已有的API去很容易实现，如<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility" target="_blank" rel="external">Function.prototype.bind</a>,或者<a href="https://github.com/remy/polyfills/blob/6e87470526c496c0fc53fa87ed5a825eff61f1f3/classList.js" target="_blank" rel="external">classList</a>,这些的代码行数非常少。<br>然而，如果是一些比较新的特性，或者是涉及到了CSS语法，就比较难写了。比如<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events" target="_blank" rel="external">pointer events</a>。因为它依赖于<code>touch-action</code>这个属性，但是如果浏览器不支持它，就会直接将它忽略掉。因此实现起来就比较困难。Polymer会要求你将<code>touch-action</code>作为一个元素属性，而微软的polyfill则直接进行了对所有设定样式的标签的内容进行搜索的过程，这显然会对性能上产生影响。<br>事实上，对Web components进行polyfill是十分困难的。下面是几个例子。</p>
<h3 id="web_components中疯狂的polyfill">web components中疯狂的polyfill</h3>
<p>首先，考虑一下如何polyfill Shadow DOM。因为Shadow DOM中的内容是不能使用<code>querySelector</code>和<code>querySelectorAll</code>来查找到的，但是我们怎么样才能实现后达到这个效果？想想都觉得很难。但是事实却是polymer做到了这一点，它是如何做的呢？</p>
<p>事实就是，polymer封装了大量的DOM方法，<a href="https://github.com/Polymer/ShadowDOM/blob/master/src/wrappers/Document.js" target="_blank" rel="external">至少25个</a>，同时为<a href="https://github.com/Polymer/ShadowDOM/tree/master/src/wrappers" target="_blank" rel="external">超过30个</a>元素提供了将元素从DOM中移除，然后保留在内部的列表中的接口。<br>Shadow DOM的规范中也定义了为Shadow DOM中的元素进行暴露或者选择的CSS接口。因为浏览器对于它不理解的CSS选择器会直接丢掉，因此我们不得不去对<code>style</code>和<code>&lt;link rel=&quot;stylesheet&quot;&gt;</code>标签中的内容进行搜索。platform.js中关于里面的正则表达式有<a href="https://github.com/Polymer/platform-dev/blob/fe5427b747e5bca3dde9ba891cb33d279faff3f9/src/ShadowCSS.js#L544-581" target="_blank" rel="external">38行</a>之多，你可以体会一下是多么的复杂。<br><img src="http://developer.telerik.com/wp-content/uploads/2014/07/687474703a2f2f692e696d6775722e636f6d2f473659467072742e706e67.png" alt=""></p>
<h2 id="我们为什么要关心它">我们为什么要关心它</h2>
<h3 id="并非所有的特性都被polyfill了">并非所有的特性都被polyfill了</h3>
<p>但是，既然Google已经完成了这项很艰难的工作，我们为什么还要关心它有多难呢？因为它的复杂程度也会影响到生产环境中的使用。比如：并不是所有的内容都被polyfill了，尤其是有关于Shadow DOM中的一些规范。Shadow CSS中说到：</p>
<blockquote>
<p>“The intention here is to support only the styling features which can be relatively simply implemented. The goal is to allow users to avoid the most obvious pitfalls and do so without compromising performance significantly.”</p>
</blockquote>
<p>尽管它说很简单，我们可不这么想。因为polyfill Shadow DOM实际上意味着使用Javascript来重写CSS,显然这么做有些过了。</p>
<p>对于web开发人员来说比较尴尬的是，他们不知道究竟哪些能用，哪些又因为没有被实现不能用，比如下图中，对于Shadow DOM中h1的样式设置，在Chrome和Safari中就有所区别：<br><img src="/image/differ.png" alt=""><br>左图中外部的css设置明显影响到了Shadow DOM中的元素的样式。</p>
<h3 id="文件大小">文件大小</h3>
<p>另一方面就是，polyfill的代码行数多导致文件很大。对于平台的polyfill在没压缩前达到151KB,压缩后也有44KB。如果使用了Polymer，还要再增加20KB大小。<br>Polymer做的很好的一点就是它把polyfill分成了一个一个模块，这样你就可以有选择的使用。但是实际上使用中却不是这样，因为所有的polymer 元素，以及<a href="http://customelements.io/" target="_blank" rel="external">http://customelements.io/</a>上的大部分元素，都依赖整个Polymer，也就是要有所有的平台的polyfill才行。</p>
<h3 id="性能原因">性能原因</h3>
<p>Polymer还没有做有关性能的测试，不可避免的是因为有这些polyfill存在，速度上不会很快。另外，使用了HTML imports也会导致很多的请求。尽管HTML import本身的想法很好，即每一个都是一个完整的组件，包含了相关的模板，CSS和Javascript代码等等，但是如果一个依赖于多个其他的资源，那么每一个资源都会导致一个请求的产生。<br>在Chrome中，由于本地支持HTML import，它能够使用并行的连接以及<a href="http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#Speculative_parsing" target="_blank" rel="external">推测性的解析算法</a>去优化整个加载过程，但是在其他浏览器中，因为无法做到这点，只能靠<code>XHR</code>来完成了。<br>还有，如果是在一个网络环境很慢的移动设备上，即使是访问一个web component的demo也会变得很慢。比如在IOS手机上访问polymer官网就是一个例子。<br>好的消息是，有些工具正试图解决这样的问题，比如<a href="https://github.com/Polymer/vulcanize" target="_blank" rel="external">Vulcanize</a>构建工具，你可以传递给他一个HTML文件，它能够分析出HTML import的依赖关系，最后把它们内联到一个文件中。比如，你可以传入一个index.html，然后构建为一个built.html：</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>vulcanize -o built<span class="preprocessor">.html</span> index<span class="preprocessor">.html</span>
</pre></td></tr></table></figure><br>还有很多类似的工具，虽然很好，但是你不得不事先去做大量的调研工作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/08/11/【译】：为什么Web-Components还不适合于生产环境/" data-id="2qlj7wyrce43pxo4" class="article-share-link">分享到</a>
      
        <a href="http://yoursite.com/2014/08/11/【译】：为什么Web-Components还不适合于生产环境/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webcomponent/">webcomponent</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-【译】：创建自己的AngularJS应用----Scope和Digest" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/11/【译】：创建自己的AngularJS应用----Scope和Digest/" class="article-date">
  <time datetime="2014-08-11T03:43:50.000Z" itemprop="datePublished">8月 11 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/11/【译】：创建自己的AngularJS应用----Scope和Digest/">【译】：创建自己的AngularJS应用 -- Scope和Digest</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文地址：<a href="http://teropa.info/blog/2013/11/03/make-your-own-angular-part-1-scopes-and-digest.html" target="_blank" rel="external">http://teropa.info/blog/2013/11/03/make-your-own-angular-part-1-scopes-and-digest.html</a><br>Angular是一个非常成熟并且强大的框架，同时有很多新的思想。然而使用者通常会遇到一些相似的问题：digest究竟是什么？创建一个directive有几种方法？service和provider有什么区别？<br>在这篇文章中，将从头搭建一个Angular的实现，这样，在这个过程中，我们会对Angular如何工作有一个更深的认知。</p>
<p>首先我们要看的就是<code>scope</code>以及<code>$eval,$digest,$apply</code>是如何工作的。对于一些基本操作，我们使用<a href="http://lodash.com/" target="_blank" rel="external">Lo-Dash</a>这个库。虽然Angular本身并不使用它，但是我们可以避免很多底层代码。在程序中，它的变量名是一个下划线<code>_</code>，就像underscore那样。<br>最后，我们会使用<code>console.assert</code>来进行一些基本测试。关于Lo-Dash和console.assert的用法可以看一下下面的例子：</p>
<iframe src="http://jsbin.com/UGOVUk/4/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px;"></iframe>

<h2 id="Scope对象">Scope对象</h2>
<p>Angular中的Scope是原生的Javascript对象，我们可以在之上增加一些属性。同时我们也可以自己通过构造函数去创建一个scope:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">var</span> aScope = <span class="keyword">new</span> Scope();
aScope.firstName = <span class="string">'Jane'</span>;
aScope.lastName = <span class="string">'Smith'</span>;
</pre></td></tr></table></figure>

<p>就是很简单的对象属性，没有什么特殊的。</p>
<h2 id="使用$watch和$digest监测对象的属性">使用$watch和$digest监测对象的属性</h2>
<p><code>$watch</code>和<code>$digest</code>两者并肩合作，共同解决了对数据的变化做出响应的问题。<br><code>watcher</code>能够在scope里的数据变化发生时得到通知，而<code>$watch</code>方法则用来创建一个watcher，创建时有两个参数：</p>
<ul>
<li><em>watcher function</em>：表明了你所感兴趣的数据有哪些，在Angular中，更多的是使用一个表达式来完成，如<code>user.firstName</code></li>
<li><em>listener function</em>： 数据变化时采取什么样的操作<br>所有的watch方法会被保留在一个数组中。当一个变量以<strong>$$</strong>来开头时，表明它对框架本身是私有的，因此不能在应用的代码中出现。<br>现在我们定义自己的$watch方法，它会接收两个函数作为参数，同时保存到$$watchers数组中。由于我们希望所有的scope都有这个方法，因此我们会将它添加到原型中：<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Scope</span><span class="params">()</span> {</span>
  <span class="keyword">this</span>.$$watchers = [];
}

Scope.prototype.$watch = <span class="function"><span class="keyword">function</span><span class="params">(watchFn, listenerFn)</span> {</span>
  <span class="keyword">var</span> watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn
  };
  <span class="keyword">this</span>.$$watchers.push(watcher);
};

Scope.prototype.$digest = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  _.forEach(<span class="keyword">this</span>.$$watchers, <span class="function"><span class="keyword">function</span><span class="params">(watch)</span> {</span>
    watch.listenerFn();
  });
};
</pre></td></tr></table></figure>

</li>
</ul>
<p>digest方法的实现就是执行所有注册过的watch方法。下面例子体现了到目前为止的功能：</p>
<iframe src="http://jsbin.com/oMaQoxa/2/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px;"></iframe>

<h2 id="检查脏数据">检查脏数据</h2>
<p>watch函数通常要返回那些我们感兴趣的数据，这些数据是在scope这个范围当中的，因此，通常scope会作为watch函数的一个参数，然后从scope中拉取一些数据并返回。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span><span class="params">(scope)</span> {</span>
  <span class="keyword">return</span> scope.firstName;
}
</pre></td></tr></table></figure>

<p>$digest函数的作用是调用watch函数，将它返回值和上次的值进行比对，如果发生了变化，就说明这个watcher是脏的，这样相应的listener需要被调用。这里我们实现上则直接使用一个<code>last</code>属性来保存上次的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>Scope.prototype.$digest = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  _.forEach(<span class="keyword">this</span>.$$watchers, <span class="function"><span class="keyword">function</span><span class="params">(watch)</span> {</span>
    <span class="keyword">var</span> newValue = watch.watchFn(self);
    <span class="keyword">var</span> oldValue = watch.last;
    <span class="keyword">if</span> (newValue !== oldValue) {
      watch.listenerFn(newValue, oldValue, self);
      watch.last = newValue;
    }
  });
};
</pre></td></tr></table></figure>

<p>对每一个watcher来说，我们调用它，将scope作为参数。然后比对返回值和last属性的值。如果变化，则调用对应的listener。最后，重新赋值last属性。<br>有了这个实现，我们就可以检测数据变化了：</p>
<iframe src="http://jsbin.com/OsITIZu/5/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px;"></iframe>

<p>我们已经看到Angular的Scope上有一些重要的性能特点：</p>
<ul>
<li>如果仅仅在Scope上修改数据，如果没有watcher来监控它，UI层并不会变化。而且，属性不一定必须在Scope中，事实上，Angular检测的是所有的watch，而不是scope上的所有属性。</li>
<li>每一次$digest都会调用watch函数。因此需要注重一下我们所拥有的watch函数的数目，因为这样会影响到性能。</li>
</ul>
<h2 id="从digest中得到通知">从digest中得到通知</h2>
<p>如果你只是想要在digest过程中得到通知，也就是只是想在每一次digest时做些处理，但并不是监控数据，那么你可以将listener函数置空。由于我们并不想监测什么，我们的watch函数不返回内容就行了，这样watch的对象始终就是<code>undefined</code>:</p>
<iframe src="http://jsbin.com/OsITIZu/6/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px;"></iframe>

<p>我们已经实现了一些核心内容，但这还远远不够。例如，有个场景就是，在listener函数中，我们仍然改变了数据，并且这些数据有对应的watcher，这样对应watcher的listener则不会被调用：</p>
<iframe src="http://jsbin.com/eTIpUyE/3/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px;"></iframe>

<h2 id="如果数据是脏的，则一直digest">如果数据是脏的，则一直digest</h2>
<p>为了解决上面的问题，我们需要一直进行检测，直到所有的数据都不再变化为止。<br>首先，需要将上面的$digest函数重构为$digestOnce函数，也就是只运行一次所有的watcher，并且我们还要返回是不是有的数据值变了，也就是出现了脏值的情况。<br>然后，我们还要写一个循环，循环中一直调用$digestOnce，直到没有脏值为止。由于使用了do-while，因此至少会执行一轮代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>Scope.prototype.$$digestOnce = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> self  = <span class="keyword">this</span>;
  <span class="keyword">var</span> dirty;
  _.forEach(<span class="keyword">this</span>.$$watchers, <span class="function"><span class="keyword">function</span><span class="params">(watch)</span> {</span>
    <span class="keyword">var</span> newValue = watch.watchFn(self);
    <span class="keyword">var</span> oldValue = watch.last;
    <span class="keyword">if</span> (newValue !== oldValue) {
      watch.listenerFn(newValue, oldValue, self);
      dirty = <span class="literal">true</span>;
      watch.last = newValue;
    }
  });
  <span class="keyword">return</span> dirty;
};

Scope.prototype.$digest = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> dirty;
  <span class="keyword">do</span> {
    dirty = <span class="keyword">this</span>.$$digestOnce();
  } <span class="keyword">while</span> (dirty);
};
</pre></td></tr></table></figure>

<p>接下来我们再运行上面的例子就不会有原来的问题了。<br>我们需要意识到，watch本身在一次digest过程中可能会运行多次。任何一个watch都不应该有副作用。如果一个watch函数里面做了一次ajax请求，但是实际上，我们无法保证究竟发出了多少请求。因为watch可能被调用了多次，对应的请求也发出了多次，这样就有了副作用，我们就要好好想想watch应不应该这样写。<br>上述实现有一个明显的漏洞：如果两个watch相互检测怎么办？这样的话，就没有一个稳定的状态了。比如，我们把下面例子的scope.digest给取消注释试一试：</p>
<iframe src="http://jsbin.com/eKEvOYa/4/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px;"></iframe>

<p>在我自己的机器上，运行一会页面就卡住了，因为cpu一直在运行这个循环。</p>
<h2 id="对于不稳定的digest，采取放弃策略">对于不稳定的digest，采取放弃策略</h2>
<p>放弃是指循环需要设置一个上限，如果到了这个上限，仍然不稳定，我们只能抛出一个异常了。这个上限值通常叫做TTL(Time To Live)，默认值是10。也许你认为它太小了，那么你要注意下这个值和性能有很大的关系，通常情况下我们不需要10次以上的检查。实现起来就是这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>Scope.prototype.$digest = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> ttl = <span class="number">10</span>;
  <span class="keyword">var</span> dirty;
  <span class="keyword">do</span> {
    dirty = <span class="keyword">this</span>.$$digestOnce();
    <span class="keyword">if</span> (dirty && !(ttl--)) {
      <span class="keyword">throw</span> <span class="string">"10 digest iterations reached"</span>;
    }
  } <span class="keyword">while</span> (dirty);
};
</pre></td></tr></table></figure>

<iframe src="http://jsbin.com/uNapUWe/3/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px;"></iframe>

<h2 id="基于属性值的脏检查">基于属性值的脏检查</h2>
<p>目前为止我们实现比较时使用的是<strong> === </strong>操作符，通常情况下这没有问题，但是有时候我们要比较的是object内部或者array内部的值，这样我们要检测的就不是引用了，而是真正的值。这种类型的检测我们可以通过传入第三个参数来进行标记：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>Scope.prototype.$watch = <span class="function"><span class="keyword">function</span><span class="params">(watchFn, listenerFn, valueEq)</span> {</span>
  <span class="keyword">var</span> watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn,
    valueEq: !!valueEq
  };
  <span class="keyword">this</span>.$$watchers.push(watcher);
};
</pre></td></tr></table></figure>

<p>我们把第三个参数转换为了Boolean，这样，当用户没有传入第三个参数的时候，它就是false。<br>基于属性值的检测方案意味着我们必须对数据进行遍历，从而发现它包含的内容是否发生变化。这里，我们借用了Lo-Dash的<code>isEqual</code>方法简化实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Scope.prototype.$$areEqual = <span class="function"><span class="keyword">function</span><span class="params">(newValue, oldValue, valueEq)</span> {</span>
  <span class="keyword">if</span> (valueEq) {
    <span class="keyword">return</span> _.isEqual(newValue, oldValue);
  } <span class="keyword">else</span> {
    <span class="keyword">return</span> newValue === oldValue;
  }
};
</pre></td></tr></table></figure>

<p>之前我们保存的last是引用地址，这样一来比较的始终是引用地址，数据变化了之后last也会跟着变化。因此我们需要做的就是一次深拷贝操作，所以我们需要更新一下实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>Scope.prototype.$$digestOnce = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> self  = <span class="keyword">this</span>;
  <span class="keyword">var</span> dirty;
  _.forEach(<span class="keyword">this</span>.$$watchers, <span class="function"><span class="keyword">function</span><span class="params">(watch)</span> {</span>
    <span class="keyword">var</span> newValue = watch.watchFn(self);
    <span class="keyword">var</span> oldValue = watch.last;
    <span class="keyword">if</span> (!self.$$areEqual(newValue, oldValue, watch.valueEq)) {
      watch.listenerFn(newValue, oldValue, self);
      dirty = <span class="literal">true</span>;
      watch.last = (watch.valueEq ? _.cloneDeep(newValue) : newValue);
    }
  });
  <span class="keyword">return</span> dirty;
};
</pre></td></tr></table></figure>

<iframe src="http://jsbin.com/ARiWENO/4/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px;"></iframe>

<p>基于属性值的检测方案不仅涉及到了更多的操作，而且遍历复杂的数据结构可能会消耗时间，同时深拷贝也会占据内存空间。所以默认的不会采用这种方案。</p>
<h2 id="NaN">NaN</h2>
<p>在Javascript中，我们知道<code>NaN</code>代表Not a Number，它是不等于自身的(<code>NaN!==NaN 为true</code>)。基于这个事实，如果一个watch返回了NaN，那么脏值检查将无休止。<br>对于基于值的脏检查策略来说，我们已经可以通过Lo-Dash的<code>isEqual</code>方法避免它，但是对于基于引用的策略来说，我们需要处理一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>Scope.prototype.$$areEqual = <span class="function"><span class="keyword">function</span><span class="params">(newValue, oldValue, valueEq)</span> {</span>
  <span class="keyword">if</span> (valueEq) {
    <span class="keyword">return</span> _.isEqual(newValue, oldValue);
  } <span class="keyword">else</span> {
    <span class="keyword">return</span> newValue === oldValue ||
      (<span class="keyword">typeof</span> newValue === <span class="string">'number'</span> && <span class="keyword">typeof</span> oldValue === <span class="string">'number'</span> &&
       <span class="built_in">isNaN</span>(newValue) && <span class="built_in">isNaN</span>(oldValue));
  }
};
</pre></td></tr></table></figure>

<p>这样，NaN就不会有什么问题了：</p>
<iframe src="http://jsbin.com/ijINaRA/3/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px;"></iframe>

<h2 id="$eval：在scope上下文中执行代码">$eval：在scope上下文中执行代码</h2>
<p><code>$eval</code>是Angular中在scope中运行代码的最简单的方法。它使用一个函数作为参数，并且把scope传递给这个函数，然后立马执行它。$eval的返回就是那个函数参数的返回。同时还有一个可选的参数，$eval会将它原封不动的传给第一个函数参数。<br>无论是实现还是使用都是非常明了的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>Scope.prototype.$<span class="built_in">eval</span> = <span class="function"><span class="keyword">function</span><span class="params">(expr, locals)</span> {</span>
  <span class="keyword">return</span> expr(<span class="keyword">this</span>, locals);
};
</pre></td></tr></table></figure>


<iframe src="http://jsbin.com/UzaWUC/3/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px;"></iframe>

<p>为什么我们会使用这种看似迂回的方式去调用一个函数呢？因为相比于直接调用一个函数，$eval看起来更加的明确，它就是为了在scope上下文中执行一些代码的。同时，我们不仅仅可以传递函数，也可以传递表达式，表达式会被编译后运行。最后，$eval也是$apply实现的基石。</p>
<h2 id="$apply：将运行外部代码和digest生命周期整合一起">$apply：将运行外部代码和digest生命周期整合一起</h2>
<p>如果我们想要将外部的库整合到Angular中，$apply可能是一种常见的做法，它将一个函数作为参数，执行它，然后开始$digest周期。简单来说就是这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Scope.prototype.$apply = <span class="function"><span class="keyword">function</span><span class="params">(expr)</span> {</span>
  <span class="keyword">try</span> {
    <span class="keyword">return</span> <span class="keyword">this</span>.$<span class="built_in">eval</span>(expr);
  } <span class="keyword">finally</span> {
    <span class="keyword">this</span>.$digest();
  }
};
</pre></td></tr></table></figure>

<p>$apply起到的作用是，它可以执行一些Angular本身并不认识的代码。并且如果这些代码对数据产生了变化，我们也更新它。</p>
<iframe src="http://jsbin.com/UzaWUC/4/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px;"></iframe>

<h2 id="$evalAsync：延迟执行">$evalAsync：延迟执行</h2>
<p>在Angular中，我们想要延迟代码执行，可以使用<code>$timeout</code>这个服务，也可使用<code>$evalAsync</code>，它接收一个函数作为参数，这个函数会在下次digest时执行，如果当前digest在进行中，则在当前digest时执行。总之就是延迟执行。<br>为了实现它，需要将所有延迟的任务保存到一个数组中，然后在digest时逐个调用这个数组中的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Scope</span><span class="params">()</span> {</span>
  <span class="keyword">this</span>.$$watchers = [];
  <span class="keyword">this</span>.$$asyncQueue = [];
}

Scope.prototype.$evalAsync = <span class="function"><span class="keyword">function</span><span class="params">(expr)</span> {</span>
  <span class="keyword">this</span>.$$asyncQueue.push({scope: <span class="keyword">this</span>, expression: expr});
};

Scope.prototype.$digest = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> ttl = <span class="number">10</span>;
  <span class="keyword">var</span> dirty;
  <span class="keyword">do</span> {
    <span class="keyword">while</span> (<span class="keyword">this</span>.$$asyncQueue.length) {
      <span class="keyword">var</span> asyncTask = <span class="keyword">this</span>.$$asyncQueue.shift();
      <span class="keyword">this</span>.$<span class="built_in">eval</span>(asyncTask.expression);
    }
    dirty = <span class="keyword">this</span>.$$digestOnce();
    <span class="keyword">if</span> (dirty && !(ttl--)) {
      <span class="keyword">throw</span> <span class="string">"10 digest iterations reached"</span>;
    }
  } <span class="keyword">while</span> (dirty);
};
</pre></td></tr></table></figure>

<p>这样就可以延迟运行了：</p>
<iframe src="http://jsbin.com/ilepOwI/2/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px;"></iframe>

<h2 id="scope的几个阶段">scope的几个阶段</h2>
<p>$evalAsync的另一个作用是，调度一次$digest，也就是说，可以肯定很快会有一次$digest。<br>我们需要知道当前$digest是否在进行中，因为如果$digest正在进行中的话，那就没有必要再调度一次$digest了。Angular中就有一个字符串属性<em>phase</em>，它存储了当前是哪一个阶段。<br>为了主动设定一个阶段，我们实现两个函数:<code>$beginPhase</code>和<code>$clearPhase</code>。只有当当前不处于任何阶段的情况下，才可以设置一个新的阶段。<br>然后，在$digest函数中，我们就可以设置和清除digest阶段了。同理，$apply里面也要进行添加。最后，$evalAsync里面，需要查看状态，只有不在任何阶段时，才进行一次调度：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Scope</span><span class="params">()</span> {</span>
  <span class="keyword">this</span>.$$watchers = [];
  <span class="keyword">this</span>.$$asyncQueue = [];
  <span class="keyword">this</span>.$$phase = <span class="literal">null</span>;
}

Scope.prototype.$beginPhase = <span class="function"><span class="keyword">function</span><span class="params">(phase)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>.$$phase) {
    <span class="keyword">throw</span> <span class="keyword">this</span>.$$phase + <span class="string">' already in progress.'</span>;
  }
  <span class="keyword">this</span>.$$phase = phase;
};

Scope.prototype.$clearPhase = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">this</span>.$$phase = <span class="literal">null</span>;
};

Scope.prototype.$digest = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> ttl = <span class="number">10</span>;
  <span class="keyword">var</span> dirty;
  <span class="keyword">this</span>.$beginPhase(<span class="string">"$digest"</span>);
  <span class="keyword">do</span> {
    <span class="keyword">while</span> (<span class="keyword">this</span>.$$asyncQueue.length) {
      <span class="keyword">var</span> asyncTask = <span class="keyword">this</span>.$$asyncQueue.shift();
      <span class="keyword">this</span>.$<span class="built_in">eval</span>(asyncTask.expression);
    }
    dirty = <span class="keyword">this</span>.$$digestOnce();
    <span class="keyword">if</span> (dirty && !(ttl--)) {
      <span class="keyword">this</span>.$clearPhase();
      <span class="keyword">throw</span> <span class="string">"10 digest iterations reached"</span>;
    }
  } <span class="keyword">while</span> (dirty);
  <span class="keyword">this</span>.$clearPhase();
};

Scope.prototype.$apply = <span class="function"><span class="keyword">function</span><span class="params">(expr)</span> {</span>
  <span class="keyword">try</span> {
    <span class="keyword">this</span>.$beginPhase(<span class="string">"$apply"</span>);
    <span class="keyword">return</span> <span class="keyword">this</span>.$<span class="built_in">eval</span>(expr);
  } <span class="keyword">finally</span> {
    <span class="keyword">this</span>.$clearPhase();
    <span class="keyword">this</span>.$digest();
  }
};

Scope.prototype.$evalAsync = <span class="function"><span class="keyword">function</span><span class="params">(expr)</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  <span class="keyword">if</span> (!self.$$phase && !self.$$asyncQueue.length) {
    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">if</span> (self.$$asyncQueue.length) {
        self.$digest();
      }
    }, <span class="number">0</span>);
  }
  self.$$asyncQueue.push({scope: self, expression: expr});
};
</pre></td></tr></table></figure>

<p>现在，我们可以确保肯定会进入到digest里面了。</p>
<iframe src="http://jsbin.com/iKeSaGi/2/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px;"></iframe>

<h2 id="$$postDigest_-_在digest阶段之后执行代码">$$postDigest - 在digest阶段之后执行代码</h2>
<p>$$postDigest的意思是，digest之后会被调度执行，和$evalAsync一样，也要有一个数组来保存需要执行的东西。这里名字中含有两个<code>$</code>符，是说明它是一个内部的方法。</p>
<iframe src="http://jsbin.com/IMEhowO/5/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px;"></iframe>

<h2 id="异常处理">异常处理</h2>
<p>Angular的scope是非常健壮的，当watch函数，$evalAsync函数或者是$$postDigest函数里面跑出了异常，并不会中端digest操作。但是我们现在的实现却有这个问题。我们简单起见，将代码包裹在try-catch里面，但是Angular中，实际上有一个<code>$exceptionHandler</code>来负责处理异常的。</p>
<iframe src="http://jsbin.com/IMEhowO/6/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px;"></iframe>

<h2 id="销毁一个watch">销毁一个watch</h2>
<p>有些情况下你会希望销毁一个特定的watch。在Angular中，watch函数有一个返回值，它也是一个函数，并且调用后会把这个watch给销毁掉。所以我们也这样去做：</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>Scope.prototype.$watch = <span class="function"><span class="keyword">function</span><span class="params">(watchFn, listenerFn, valueEq)</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  <span class="keyword">var</span> watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn,
    valueEq: !!valueEq
  };
  self.$$watchers.push(watcher);
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> index = self.$$watchers.indexOf(watcher);
    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) {
      self.$$watchers.splice(index, <span class="number">1</span>);
    }
  };
};
</pre></td></tr></table></figure></p>
<iframe src="http://jsbin.com/IMEhowO/7/embed?js,console" class="jsbin-embed" id="" style="border: 1px solid rgb(170, 170, 170); width: 100%; min-height: 300px; height: 208px;"></iframe>

<h2 id="更进一步">更进一步</h2>
<p>我们已经实现了一些基本的功能，但是事实上Angular中包含的还有很多。比如，scope可以有继承关系，子scope可以watch父scope中的变化。虽然这很简单，但是给很多初学者往往带来困惑。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/08/11/【译】：创建自己的AngularJS应用----Scope和Digest/" data-id="5go6599bynz2i27k" class="article-share-link">分享到</a>
      
        <a href="http://yoursite.com/2014/08/11/【译】：创建自己的AngularJS应用----Scope和Digest/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/framework/">framework</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-【译】：Throne-of-JS会议华山论剑之Javascript富应用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/09/【译】：Throne-of-JS会议华山论剑之Javascript富应用/" class="article-date">
  <time datetime="2014-08-09T00:19:05.000Z" itemprop="datePublished">8月 9 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/09/【译】：Throne-of-JS会议华山论剑之Javascript富应用/">【译】：Throne of JS会议华山论剑之Javascript富应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://throneofjs.com/" target="_blank" rel="external">Throne of JS</a>是一个时长为两天的大会，会议会将许多的Javascript框架创建者召集起来，并让他们互相切磋讨论。而框架的使用者可以从中得到的好处是，能够更好的做出选择，从而在合适的地方选择合适的框架。<br>之所以有这个大会，是因为它希望我们明白，构建快捷、响应式的富web应用是未来的趋势，而不是先加载完页面、而后才进行动态扩展这样的一个模式。原话就是：</p>
<blockquote>
<p>It’s no longer good enough to build web apps around full page loads and then “progressively enhance” them to behave more dynamically. Building apps which are fast, responsive and modern require you to completely rethink your approach.</p>
</blockquote>
<p>下面就是对2012年的这次大会的一个总结。<a href="http://blog.stevensanderson.com/2012/08/01/rich-javascript-applications-the-seven-frameworks-throne-of-js-2012/" target="_blank" rel="external">原文地址</a></p>
<h1 id="技术点上的异和同">技术点上的异和同</h1>
<h2 id="一致点1：_渐进增强的方式不适合构建真正的应用">一致点1： 渐进增强的方式不适合构建真正的应用</h2>
<p>这一点的意思就是，仅仅是服务器端渲染加上一些ajax、jQuery代码是远远不够的，真正的客户端Javascript应用必须要有client-side rendering的能力，并且要有合适的数据模型才行。</p>
<h2 id="一致点2：_Model-View-Whatever">一致点2： Model-View-Whatever</h2>
<p>会议讨论的所有框架都使用了模型和视图分离的技术。其中一些专门指向MVC，一些是有关MVVM的，而另一些则拒绝为剩下的部分进行定义。但是它们的最终结果则是相似的。</p>
<h2 id="一致点3：_数据绑定很重要">一致点3： 数据绑定很重要</h2>
<p>除了backbone和Spine之外，都在视图内提供了一个内置的声明式的数据绑定的方式。</p>
<h2 id="一致点4：_IE6已死">一致点4： IE6已死</h2>
<p>大多数的框架支持点仅限于IE 7之上。我们知道，jQuery也已经放弃了对IE 9以下的浏览器的支持。仅仅有backbone和Knockout支持IE 6.</p>
<h2 id="一致点5：_license和代码控制">一致点5： license和代码控制</h2>
<p>几乎所有的框架都适用了MIT许可证以及将代码托管在了Github上。</p>
<h2 id="不一致点1：_库和框架">不一致点1： 库和框架</h2>
<p>区别点在于：</p>
<ul>
<li>库作为一种插件的形式嵌入到应用中，并且它会提供一些特定的功能</li>
<li>框架则是指定了一种必须遵循的架构，如文件结构必须要和它设定的相同才行。使用框架不仅是为了解决某一个特定的功能需求，而是为了处理所有常见的需求</li>
</ul>
<table>
<thead>
<tr>
<th>库</th>
<th>框架</th>
</tr>
</thead>
<tbody>
<tr>
<td>Backbone (9552)</td>
<td>Ember (3993)</td>
</tr>
<tr>
<td>Knockout (2357)</td>
<td>AngularJS (2925)</td>
</tr>
<tr>
<td>Spine (2017)</td>
<td>Batman (958)</td>
</tr>
<tr>
<td>CanJS (321)</td>
<td>Meteor (4172)</td>
</tr>
</tbody>
</table>
<p>这里边的数字代表了框架流行程度(当然现在已经有很大的不同了)。Ember是一个框架，它的作者就认为，如果想要推进未来技术的发展，仅仅做一些零碎的工作是不行的，必须要有雄心壮志。而它的反方则认为，相比于框架而言，库的关注点更加明确，用户可以更加容易上手并自定义，同时减少了项目的风险，因为项目的架构不必和框架本身紧紧耦合在一起。</p>
<h2 id="不一致点2：_哪一个更灵活">不一致点2： 哪一个更灵活</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>views</th>
<th>URL routing</th>
<th>Data Storage</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>AngularJS</strong></td>
<td>Built-in DOM-based templates (mandatory)</td>
<td>Built-in (optional)</td>
<td>Built-in system (optional)</td>
</tr>
<tr>
<td><strong>Backbone</strong></td>
<td>Choose your own (most used handlebars.js, a string-based template library)</td>
<td>Built-in (optional)</td>
<td>Built-in (overridable)</td>
</tr>
<tr>
<td><strong>Batman</strong></td>
<td>Built-in DOM-based templates (mandatory)</td>
<td>Built-in (mandatory)</td>
<td>Built-in system (mandatory)</td>
</tr>
<tr>
<td><strong>CanJS</strong></td>
<td>Built-in string-based templates (mandatory)</td>
<td>Built in (optional)</td>
<td>Built in (optional)</td>
</tr>
<tr>
<td><strong>Ember</strong></td>
<td>Built-in string-based templates (mandatory)</td>
<td>Built-in (mandatory)</td>
<td>Built-in (overridable)</td>
</tr>
<tr>
<td><strong>Knockout</strong></td>
<td>Built-in DOM-based templates (optional, can do string-based too)</td>
<td>Choose your own (most use sammy.js or history.js)</td>
<td>Choose your own (e.g., knockout.mapping or just $.ajax)</td>
</tr>
<tr>
<td><strong>Meteor</strong></td>
<td>Built-in string-based templates (mandatory)</td>
<td>Built-in (mandatory?)</td>
<td>Built-in (Mongo, mandatory)</td>
</tr>
<tr>
<td><strong>Spine</strong></td>
<td>Choose your own string-based templates</td>
<td>Built-in (optional)</td>
<td>Built-in (optional?)</td>
</tr>
</tbody>
</table>
<p>正如预期的那样，库的开发者认为，能够保证与任何的第三方库自由组合更好；而相反的一方认为，如果是使用内置的东西，则可以更加无缝的集成。</p>
<h2 id="不一致点3：_基于字符串的和基于DOM的模板">不一致点3： 基于字符串的和基于DOM的模板</h2>
<p>上面的框架但凡是基于字符串的模板，几乎都是使用了<code>Handlebars.js</code>这一模板引擎。支持者认为这样更快，并且理论上服务器端也可以进行渲染这里的模板。实际上这两点都存在者争议。<br>基于DOM的模板意味着，一些模板元素比如流程控制等，是直接绑定在真实的标签元素上的，而不需要单独的模板库。支持者同样认为它的好处是更快，并且更加的具有可读性，因为不存在模板和标签元素之间的鸿沟。<br>有一点需要注意的是，在未来，基于DOM的模板可能会被浏览器内置支持。AngularJS的开发团队来自Google，他们已经在Chromium上致力于这项工作了。</p>
<h2 id="不一致点4：_服务器技术的倾向">不一致点4： 服务器技术的倾向</h2>
<p>Batman和Meteor明确表态了服务器的需求：Batman为了Rails而设计，Meteor则有自己的服务器。而其他的则是对服务器上有什么不做关心。</p>
<h1 id="快速浏览">快速浏览</h1>
<h2 id="Backbone">Backbone</h2>
<ul>
<li><strong>Who</strong>: Jeremy Ashkenas</li>
<li><strong>What</strong>:<ul>
<li>Model-View, MIT license</li>
<li>体积小巧</li>
<li>松耦合 - 仅仅提供了REST风格的存储模型，并且提供了简单的路由和回调，通过它可以访问到渲染视图的阶段</li>
<li>部署在大型网站的生产环境的次数最多</li>
</ul>
</li>
<li><strong>Why</strong>:<ul>
<li>体积小，易于理解</li>
<li>可以仅仅工作于页面中的一部分，而不是整个页面</li>
<li>作者Jeremy冷静沉稳，往往能提出合理的意见</li>
</ul>
</li>
</ul>
<h2 id="Meteor">Meteor</h2>
<ul>
<li><strong>Who</strong>: <a href="http://www.meteor.com/about/people" target="_blank" rel="external">Meteor开发组</a>,由于获得了可观的投资，因此可以长期致力于这项工作</li>
<li><strong>What</strong>:<ul>
<li>思维独特，和其他框架有所不同</li>
<li>将客户端代码和服务器端运行环境整合起来，因此代码可以在两端都运行。<code>WebSocket</code>负责在两者之间进行同步。</li>
<li>每次更改客户端的代码，都会同步到其他环境，并且客户端本身的状态也不会丢失</li>
<li>web开发需要更多这样的激进的技术来促使向前推动</li>
</ul>
</li>
<li><strong>Why</strong>: 这是前沿技术</li>
</ul>
<h2 id="Ember">Ember</h2>
<ul>
<li><strong>Who</strong>: Yehuda Katz</li>
<li><strong>What</strong>:<ul>
<li>在创建有雄心的web应用方面包罗万象</li>
<li>框架的体积最大，功能最全</li>
<li>在如何将页面进行层次结构的分解，以及构建分层路由系统上有很多的见解</li>
<li>复杂的数据访问库<code>Ember.Data</code></li>
<li>试图管理页面的整个生命周期，因此适用于大型的应用</li>
<li>关于文件，URL等做的很具体，但也可以进行覆盖的办法</li>
<li>设计灵感来源于<code>Rails</code>和<code>Cocoa</code></li>
<li>能够为Rails提供工程模板</li>
</ul>
</li>
<li><strong>Why</strong>: 为所有常见的问题提供了解决方案</li>
</ul>
<h2 id="AngularJS">AngularJS</h2>
<ul>
<li><strong>Who</strong>: 谷歌团队</li>
<li><strong>What</strong>:<ul>
<li>Model-View-Whatever</li>
<li>基于DOM的模板系统，并且提供了模型监听，声明式绑定以及所有MVVM的代码风格</li>
<li>基本的路由和持久化工作</li>
<li>能够在Chrome debugger中提供相应的插件，并且为Jasmine测试框架提供了插件</li>
</ul>
</li>
<li><strong>Why</strong>:<ul>
<li>概括的说，它是在浏览器现在能够做的和浏览器未来能够做的事情之间做过渡</li>
<li>对于服务器端架构没有影响，而且可以控制页面的一个部分</li>
</ul>
</li>
</ul>
<h2 id="Knockout">Knockout</h2>
<ul>
<li><strong>Who</strong>: Knockout 团队和社区</li>
<li><strong>What</strong>:<ul>
<li>MVVM</li>
<li>基于DOM的模板，提供声明式的绑定，可监控的模型，并且提供了自动的依赖检测</li>
<li>关于URL 路由和数据访问方面未有涉及，可以和任何第三方库进行组合，如Sammy.js等</li>
<li>易学，有大量的文档和可以交互的示例</li>
</ul>
</li>
<li><strong>Why</strong>:<ul>
<li>在UI层面上工作做得很足</li>
<li>同样可以控制页面的一部分</li>
</ul>
</li>
</ul>
<h2 id="Spine">Spine</h2>
<ul>
<li><strong>Who</strong>: Alex MacCaw</li>
<li><strong>What</strong>:<ul>
<li>MVC</li>
<li>起初是一本书的示例，渐渐发展为一个框架，有点像是Backbone的修正版</li>
</ul>
</li>
<li><strong>Why</strong>: 和Backbone差不多，但稍有不同。若是习惯backbone,同时想要有些不同，可以进行尝试</li>
</ul>
<h2 id="Batman">Batman</h2>
<ul>
<li><strong>Who</strong>: 来自Shoify的团队</li>
<li><strong>What</strong>:<ul>
<li>MVC,并且几乎是为了<code>Rails + CoffeeScript</code>开发者设定的</li>
<li>必须遵循它们的约定，如对于文件布局、URL等</li>
<li>完整的框架，有丰富的模型、视图、控制器、路由，基于DOM的模板</li>
</ul>
</li>
<li><strong>Why</strong>: 如果你使用Rails和CoffeeScript，那么你就来对了</li>
</ul>
<h2 id="CanJS">CanJS</h2>
<ul>
<li><strong>Who</strong>: 来自Bitovi的团队</li>
<li><strong>What</strong>:<ul>
<li>MVC</li>
<li>REST风格的持久模型，基本的路由，基于字符串的模型</li>
<li>所识之士并不多，它是老的JavascriptMVC（名字就是这个）项目的升级版</li>
</ul>
</li>
<li><strong>Why</strong>: 功能和其他类似的同时体积也很小</li>
</ul>
<h1 id="总结">总结</h1>
<p>在选择一个框架的时候，需要考虑两点：</p>
<ul>
<li><strong>使用范围</strong>： 你要用它来做什么，是从头开始并且希望它能够贯彻始终？还是仅仅作为你自己项目搭积木的一部分？</li>
<li><strong>设计美学</strong>: 你是否看过代码并且想要使用它来做一些小的东西？这么做是否使你感觉舒适？不要被它们的描述和特性列表所迷惑，真正适合自己的才是最好的，就像找对象一样，仅仅看对方的基本介绍是不够的，必须相处了才知道。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/08/09/【译】：Throne-of-JS会议华山论剑之Javascript富应用/" data-id="lvijqvdm4d31cz2e" class="article-share-link">分享到</a>
      
        <a href="http://yoursite.com/2014/08/09/【译】：Throne-of-JS会议华山论剑之Javascript富应用/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/framework/">framework</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Polymer-Getting-Started" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/03/Polymer-Getting-Started/" class="article-date">
  <time datetime="2014-08-03T01:14:50.000Z" itemprop="datePublished">8月 3 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/03/Polymer-Getting-Started/">Polymer Getting Started</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是Polymer<a href="http://www.polymer-project.org/docs/start/tutorial/intro.html" target="_blank" rel="external">官网</a>的一个例子。<br>在开始之前，要从<a href="https://github.com/Polymer/polymer-tutorial/archive/master.zip" target="_blank" rel="external">github</a>上下载工程起始的脚手架，然后解压缩。进去之后启动web服务器，然后访问<a href="http://localhost:8000/finished/" target="_blank" rel="external">http://localhost:8000/finished/</a>后，可以看到我们最终要实现的效果。</p>
<h2 id="第一步：创建骨架">第一步：创建骨架</h2>
<p>进入<em>starter</em>目录，打开<code>index.html</code>，发现里面引入了<code>platform.js</code>这个文件。此外，它还使用<code>&lt;link rel=&quot;import&quot; href=&quot;&quot;&gt;</code>来实现资源导入功能。<br>我们知道，自定义的标签元素如果没有进行注册，那么它们就处于<em>unresolved</em>状态，此时这些元素如果展示在浏览器上，由于没有按照正确的方式进行渲染，将会大大影响体验。body上的<code>unresolved</code>属性就是为了避免这种情况，即通过在CSS中设置<code>body[resolved]</code>的样式，将该状态下不正确的显示隐藏掉。<br><code>touch-action=&quot;auto&quot;</code>属性声明表明当前应用支持触摸事件。<br>接下来我们引入<code>panel</code> <code>toolbar</code> 和 <code>tabs</code>这三个组件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"import"</span> <span class="attribute">href</span>=<span class="value">"../components/core-header-panel/core-header-panel.html"</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"import"</span> <span class="attribute">href</span>=<span class="value">"../components/core-toolbar/core-toolbar.html"</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"import"</span> <span class="attribute">href</span>=<span class="value">"../components/paper-tabs/paper-tabs.html"</span>&gt;</span>
</pre></td></tr></table></figure>

<p>然后在body中声明使用这几个已有的组件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="subst">&lt;</span>core<span class="attribute">-header</span><span class="attribute">-panel</span><span class="subst">&gt;</span>
  <span class="subst">&lt;</span>core<span class="attribute">-toolbar</span><span class="subst">&gt;</span>
    <span class="subst">&lt;</span>paper<span class="attribute">-tabs</span> id<span class="subst">=</span><span class="string">"tabs"</span> selected<span class="subst">=</span><span class="string">"all"</span> <span class="built_in">self</span><span class="attribute">-end</span><span class="subst">&gt;</span>
      <span class="subst">&lt;</span>paper<span class="attribute">-tab</span> name<span class="subst">=</span><span class="string">"all"</span><span class="subst">&gt;</span><span class="literal">ALL</span><span class="subst">&lt;</span>/paper<span class="attribute">-tab</span><span class="subst">&gt;</span>
      <span class="subst">&lt;</span>paper<span class="attribute">-tab</span> name<span class="subst">=</span><span class="string">"favorites"</span><span class="subst">&gt;</span>FAVORITES<span class="subst">&lt;</span>/paper<span class="attribute">-tab</span><span class="subst">&gt;</span>
    <span class="subst">&lt;</span>/paper<span class="attribute">-tabs</span><span class="subst">&gt;</span>
  <span class="subst">&lt;</span>/core<span class="attribute">-toolbar</span><span class="subst">&gt;</span>
<span class="subst">&lt;</span>/core<span class="attribute">-header</span><span class="attribute">-panel</span><span class="subst">&gt;</span>
</pre></td></tr></table></figure>

<p>接下来修改一下样式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="tag">core-header-panel</span> <span class="rules">{
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100</span>%</span></span>;
  <span class="rule"><span class="attribute">overflow</span>:<span class="value"> auto</span></span>;
  <span class="comment">/* 确保手机上滑动时流畅 */</span>
  <span class="rule"><span class="attribute">-webkit-overflow-scrolling</span>:<span class="value"> touch</span></span>; 
<span class="rule">}</span></span>
<span class="tag">core-toolbar</span> <span class="rules">{
  <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#03a9f4</span></span></span>;
  <span class="rule"><span class="attribute">color</span>:<span class="value"> white</span></span>;
<span class="rule">}</span></span>
<span class="id">#tabs</span> <span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100</span>%</span></span>;
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>;
  <span class="comment">/* 用户不能选择元素中的任何内容 */</span>
  <span class="rule"><span class="attribute">-webkit-user-select</span>:<span class="value"> none</span></span>;
  <span class="rule"><span class="attribute">-moz-user-select</span>:<span class="value"> none</span></span>;
  <span class="rule"><span class="attribute">-ms-user-select</span>:<span class="value"> none</span></span>;
  <span class="rule"><span class="attribute">user-select</span>:<span class="value"> none</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>然后是增加选项卡选中事件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
  <span class="keyword">var</span> tabs = document.querySelector(<span class="string">'paper-tabs'</span>);
  <span class="comment">// 选中某项选项卡时就会触发</span>
  tabs.addEventListener(<span class="string">'core-select'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log(<span class="string">"Selected: "</span> + tabs.selected);
  });
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>

<p>最后浏览器访问：<a href="http://localhost:8000/starter/" target="_blank" rel="external">http://localhost:8000/starter/</a>查看到目前为止的效果：<br><img src="/image/polymer-started-1.png" alt=""></p>
<h2 id="第二步：自定义标签元素">第二步：自定义标签元素</h2>
<p>打开<em>post-card.html</em>，这是一个卡片的Component。里面就是该组件的一些定义。开始时，我们发现里面已经做了一些引入，并且创建了一个叫做<code>post-card</code>的元素。<br>在polymer中，创建一个自定义标签的方式是使用<code>polymer-element</code>标签进行声明。其中的<code>template</code>元素放的就是Shadow DOM,里面的<code>:host</code>伪类匹配了整个元素。<br>为了创建一个完整的卡片，开始时的<code>template</code>中内容还不够完善，首先我们在其中丰富这个卡片的基本结构：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"card-header"</span> <span class="attribute">layout</span> <span class="attribute">horizontal</span> <span class="attribute">center</span>&gt;</span>
  <span class="tag">&lt;<span class="title">content</span> <span class="attribute">select</span>=<span class="value">"img"</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
  <span class="tag">&lt;<span class="title">content</span> <span class="attribute">select</span>=<span class="value">"h2"</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">content</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
</pre></td></tr></table></figure>

<p>里面使用了三个<code>&lt;content&gt;</code>标签，匹配了不同的内容片断。<br>接下来仍然是添加样式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="comment">/* 如果浏览器不是本地支持Shadow DOM，那么就将紧接着的CSS选择器替换为这里的值 */</span>
<span class="tag">polyfill-next-selector</span> <span class="rules">{ <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">'.card-header h2'</span></span></span>; <span class="rule">}</span></span>
<span class="comment">/* 匹配插值点中的二级标题 */</span>
<span class="class">.card-header</span> <span class="pseudo">::content</span> <span class="tag">h2</span> <span class="rules">{
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>;
  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">1.8</span>rem</span></span>;
  <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> <span class="number">300</span></span></span>;
<span class="rule">}</span></span>
<span class="tag">polyfill-next-selector</span> <span class="rules">{ <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">'.card-header img'</span></span></span>; <span class="rule">}</span></span>
<span class="class">.card-header</span> <span class="pseudo">::content</span> <span class="tag">img</span> <span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">70</span>px</span></span>;
  <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">50</span>%</span></span>;
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">10</span>px</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>这样一来，我们就将这个卡片的自定义标签定义好了。接下来就是在<code>index.html</code>中使用这个卡片。<br>在将<em>post-card.html</em>引入之后，在core-toolbar下面就可以插入这个元素：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">post-card</span>&gt;</span>
  <span class="tag">&lt;<span class="title">img</span> <span class="attribute">width</span>=<span class="value">"70"</span> <span class="attribute">height</span>=<span class="value">"70"</span> <span class="attribute">src</span>=<span class="value">"../images/avatar-07.svg"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">h2</span>&gt;</span>Another Developer<span class="tag">&lt;/<span class="title">h2</span>&gt;</span>
  <span class="tag">&lt;<span class="title">p</span>&gt;</span>I'm composing with shadow DOM!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">post-card</span>&gt;</span>
</pre></td></tr></table></figure>

<p>依然是查看<a href="http://localhost:8000/starter/" target="_blank" rel="external">http://localhost:8000/starter/</a>，这时的效果图如下：<br><img src="/image/polymer-started-2.png" alt=""></p>
<h2 id="第三步：实现数据绑定">第三步：实现数据绑定</h2>
<p>这一步，我们需要从服务器获取数据来填充卡片。打开<em>post-list.html</em>，发现里面已经引入了<code>&lt;post-service&gt;</code>自定义标签定义。<br>增加一个<code>&lt;post-service&gt;</code>元素：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>	<span class="tag">&lt;<span class="title">post-service</span> <span class="attribute">id</span>=<span class="value">"service"</span> <span class="attribute">posts</span>=<span class="value">""</span>&gt;</span>
	<span class="tag">&lt;/<span class="title">post-service</span>&gt;</span>
</pre></td></tr></table></figure>

<p>这里定义了一个<code>posts</code>属性，且实现了自定义元素和<code>post-service</code>元素之间的双向数据绑定。也就是说，我们定义了一个叫做<code>post-list</code>的元素，里面有一个属性是<code>posts</code>，它的值是通过<code>post-service</code>元素来获得的，且两者之间实现数据的同步。<br>接着我们又在<code>template</code>元素里面插入了一个div:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">layout</span> <span class="attribute">vertical</span> <span class="attribute">center</span>&gt;</span>
  <span class="tag">&lt;<span class="title">template</span> <span class="attribute">repeat</span>=<span class="value">"</span></span></span><span class="expression">{{<span class="variable">post</span> <span class="variable"><span class="keyword">in</span></span> <span class="variable">posts</span>}}</span><span class="xml"><span class="tag"><span class="value">"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">post-card</span>&gt;</span>
      <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"</span></span></span><span class="expression">{{<span class="variable">post.avatar</span>}}</span><span class="xml"><span class="tag"><span class="value">"</span> <span class="attribute">width</span>=<span class="value">"70"</span> <span class="attribute">height</span>=<span class="value">"70"</span>&gt;</span>
      <span class="tag">&lt;<span class="title">h2</span>&gt;</span></span><span class="expression">{{<span class="variable">post.username</span>}}</span><span class="xml"><span class="tag">&lt;/<span class="title">h2</span>&gt;</span>
      <span class="tag">&lt;<span class="title">p</span>&gt;</span></span><span class="expression">{{<span class="variable">post.text</span>}}</span><span class="xml"><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">post-card</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">template</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span>
</pre></td></tr></table></figure>


<p>很显然，这是遍历了posts的值，并分别创建模板。这里很像很多MV*框架中模板里面实现数据绑定的做法。<br>最后，将index.html中有关post-card的部分替换为post-list:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>&lt;link rel=<span class="string">"import"</span> href=<span class="string">"post-list.html"</span>&gt;
  <span class="keyword">...</span>
&lt;post-list show=<span class="string">"all"</span>&gt;&lt;/post-list&gt;
</pre></td></tr></table></figure>

<p>有人可能会疑问，这里的<code>post-service</code>中的数据从哪里来的？想要知道答案的话，就打开<em>post-service.html</em>一探究竟吧。<br>这时的效果如下：<br><img src="/image/polymer-started-3.png" alt=""></p>
<h2 id="添加favicon">添加favicon</h2>
<p>首先在<em>post-card.html</em>中添加一个icon按钮，添加的位置在<code>h2</code>标签下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="subst">&lt;</span>core<span class="attribute">-icon</span><span class="attribute">-button</span>
  id<span class="subst">=</span><span class="string">"favicon"</span>
  icon<span class="subst">=</span><span class="string">"favorite"</span>
  <span class="keyword">on</span><span class="attribute">-tap</span><span class="subst">=</span><span class="string">""</span><span class="subst">&gt;</span>
<span class="subst">&lt;</span>/core<span class="attribute">-icon</span><span class="attribute">-button</span><span class="subst">&gt;</span>
</pre></td></tr></table></figure>

<p><code>core-icon</code>是polymer内置的有关图标的支持，更多介绍请看:<a href="http://www.polymer-project.org/docs/elements/icons.html" target="_blank" rel="external">Using core icons</a><br>另外我们发现上面绑定了一个触摸事件<code>favoriteTapped</code>。<br>使用Javascript插入favorite属性和favoriteTapped方法到元素的原型中，并且增加icon的css：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre>Polymer({
  <span class="comment">// 创建公共的属性</span>
  publish: {
    favorite: {
      <span class="comment">// 值是false</span>
      <span class="keyword">value</span>: <span class="keyword">false</span>,
      <span class="comment">// 一旦数值变化，就更新DOM</span>
      reflect: <span class="keyword">true</span>
    }
  },
  favoriteTapped: function(<span class="keyword">event</span>, detail, sender) {
    <span class="keyword">this</span>.favorite = !<span class="keyword">this</span>.favorite; <span class="comment">// 点击后toogle</span>
    <span class="keyword">this</span>.fire(<span class="string">'favorite-tap'</span>); <span class="comment">// 触发另外一个方法</span>
  }
});

  core-icon-button {
    position: absolute;
    top: <span class="number">3</span>px;
    right: <span class="number">3</span>px;
    fill: <span class="preprocessor">#636363;</span>
  }
  <span class="comment">/* 只有favorite为true时才适用 */</span>
  :host([favorite]) core-icon-button {
    fill: <span class="preprocessor">#da4336;</span>
  }
</pre></td></tr></table></figure>

<p>然后修改<em>post-list.html</em>,更新template中关于post-card的的声明完成数据绑定，并增加事件处理函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>&lt;post-card
      favorite=<span class="string">""</span>
      on-favorite-tap=<span class="string">""</span>
      hidden?=<span class="string">"false"</span>&gt;

Polymer({
  handleFavorite: function(event, detail, sender) {
    var post = sender<span class="preprocessor">.templateInstance</span><span class="preprocessor">.model</span><span class="preprocessor">.post</span><span class="comment">;</span>
    this.$<span class="preprocessor">.service</span><span class="preprocessor">.setFavorite</span>(post<span class="preprocessor">.uid</span>, post<span class="preprocessor">.favorite</span>)<span class="comment">;</span>
  }
})<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>可以看到第一个声明里面完成了绑定，同时使用了表达式求值。即当整个列表只显示喜爱的类型，并且当前的卡片不是喜爱的类型时，就将这个卡片进行隐藏。<br>从第二段里面，我们可以看到首先获取到了model对象，然后调用service来设置数据的值。任何Shadow DOM中拥有id的节点都可以通过<code>this.$</code>来快速访问到。</p>
<p>最后修改的是<em>index.html</em>，添加：</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> <span class="keyword">list</span> = document.querySelector(<span class="string">'post-list'</span>);

tabs.addEventListener(<span class="string">'core-select'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">list</span>.show = tabs.selected;
});
</pre></td></tr></table></figure><br>它的作用是，当点击tabs的时候，更新post-list的show属性的值。即点击all时，<code>show=all</code>；点击favorites<code>时，show=favorites</code>。<br>当我们查看结果时，可以看到favorites选项卡下显示的是我们标注的喜爱的卡片：<br><img src="/image/polymer-started-4.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/08/03/Polymer-Getting-Started/" data-id="t7x4wk830nm47kxg" class="article-share-link">分享到</a>
      
        <a href="http://yoursite.com/2014/08/03/Polymer-Getting-Started/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webcomponent/">webcomponent</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Start-Using-X-Tag" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/02/Start-Using-X-Tag/" class="article-date">
  <time datetime="2014-08-02T08:03:59.000Z" itemprop="datePublished">8月 2 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/02/Start-Using-X-Tag/">Start Using X-Tag</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="为什么要使用X-Tag">为什么要使用X-Tag</h1>
<p>经过前面两篇文章的介绍，我们已经初步领略到了Web Components的优势。但是就目前的情形来看，除了Chrome 31+以上，Web Components还没有很好的被支持。X-Tag就是一个polyfill的小型Javascript库，通过它，我们能够在现代的浏览器中使用自定义标签元素。除此之外，它还能让我们创建Custom Element的时候变得很方便。X-Tag的官网是：<a href="http://www.x-tags.org/" target="_blank" rel="external">http://www.x-tags.org/</a></p>
<h1 id="使用X-Tag创建自定义标签元素">使用X-Tag创建自定义标签元素</h1>
<p>首先来看一下官网的一个例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre>xtag.register(<span class="string">'x-accordion'</span>, {
  <span class="comment">// extend existing elements</span>
  <span class="keyword">extends</span>: <span class="string">'div'</span>,
  lifecycle:{
    created: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="comment">// fired once at the time a component</span>
      <span class="comment">// is initially created or parsed</span>
    },
    inserted: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="comment">// fired each time a component</span>
      <span class="comment">// is inserted into the DOM</span>
    },
    removed: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="comment">// fired each time an element</span>
      <span class="comment">// is removed from DOM</span>
    },
    attributeChanged: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="comment">// fired when attributes are set</span>
    }
  },
  events: {
    <span class="string">'click:delegate(x-toggler)'</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="comment">// activate a clicked toggler</span>
    }
  },
  accessors: {
    <span class="string">'togglers'</span>: {
      <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="comment">// return all toggler children</span>
      },
      <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span><span class="params">(value)</span>{</span>
        <span class="comment">// set the toggler children</span>
      }
    }
  },
  methods: {
    nextToggler: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="comment">// activate the next toggler</span>
    },
    previousToggler: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="comment">// activate the previous toggler</span>
    }
  }
});
</pre></td></tr></table></figure><br>我们可以看到，使用<code>xtag.register</code>方法可以快速创建一个<code>x-</code>开头的标签:<br>第一个部分是<strong>lifecycle</strong>，这里面对应了上篇文章提到的不同的生命周期对应的状态，从名字就可以看出来，所以就不多说了。<br>第二个部分是<strong>events</strong>，顾名思义也就是用来存放事件的地方：<br>第三个部分是<strong>accessors</strong>，它用来定义新添加的字段，以及这些元素字段之上的getter和setter方法。此外，还可以设置元素本身的属性，这时设置的就是<code>accessors: attribute</code>：<br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>xtag.register(<span class="string">'x-superinput'</span>, {
  accessors: {
    enabled: {
      <span class="built_in">attribute</span>: { boolean: true } <span class="comment">// enabled是一个属性，也就是&lt;x-superinput enabled="true"&gt;</span>
    },
    lastName: {
      <span class="built_in">attribute</span>: { name:<span class="string">'last-name'</span> } <span class="comment">// 另一个属性</span>
    }
  }
});
</pre></td></tr></table></figure>

<p>第四个部分是<strong>methods</strong>，顾名思义，就是为创建的对象上添加一些方法。<br>还有三个可以配置的部分：</p>
<ul>
<li><strong>extends</strong>: 代表标签扩展自哪一个已经存在的标签，可以使用HTML已有的标签名，如”div, span, input”</li>
<li><strong>prototype</strong>: 设置prototype的值，一般而言是<code>Object.create(HTMLDivElement.prototype)</code></li>
<li><strong>mixins</strong>: 是一个数组，里面是方法名，可以通过xtag.mixins对象进行设置新的minxin</li>
</ul>
<h2 id="Helper方法">Helper方法</h2>
<p>作为一个Javascript Library，X-Tag提供了多个帮助方法：</p>
<ul>
<li><code>toArray(obj)</code>: 将给的对象转化为数组，这里的对象不是自定义标签元素对象，而是任何一个array-like object</li>
<li><code>hasClass(element,className)/addClass/removeClass/toggleClass</code>: 对元素的class名进行操作，你懂得</li>
<li><code>matchSelector(element, selector)</code>: 判断一个元素是否匹配一个selector，返回Boolean</li>
<li><code>query(element, selector)</code>: 类似于各种选择器</li>
<li><code>queryChildren(element, selector)</code>: 只在元素的直接子元素上进行查找</li>
<li><code>requestFrame</code>: 原话是：<em> Returns an animation frame </em></li>
<li><code>createFragment(element/string)</code>: 创建一个documentFragment，也就是一个或多个相邻的Document节点和它们所有的子节点</li>
<li><code>wrap(fn1, fn2)</code>： 返回一个新的函数，会依次调用传入的两个函数</li>
<li><code>innerHTML(element, html)</code>: 为元素element设置innerHTML为html参数值</li>
<li><code>fireEvent(element,eventType,object)</code>: 触发一个事件</li>
<li><code>addEvent(element,eventType,function)</code>: 添加一个事件</li>
<li><code>addEvents(element,object)</code>: 添加多个事件</li>
</ul>
<h2 id="伪类">伪类</h2>
<p>伪类可以用于访问器、事件和方法中。<br>伪类的形式为：<strong>普通事件:delegate</strong> 或 <strong>键盘事件：keypass</strong> 即将某一个事件委托给符合参数的元素:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>xtag.register(<span class="string">'x-foo'</span>, {
    lifecycle: {
      created: <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="keyword">this</span>.innerHTML = <span class="string">'&lt;a&gt;HI&lt;/a&gt;'</span>;
      }
    },
    events: {
      <span class="string">'click:delegate(a)'</span>: <span class="function"><span class="keyword">function</span><span class="params">(e)</span>{</span>
        console.log(<span class="string">'a clicked'</span>, <span class="keyword">this</span>);
      }
    }
  });

  xtag.addEvent(input, <span class="string">'keydown:keypass(13,27)'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span>{</span>
    <span class="comment">// 'enter' or 'esc' pressed</span>
  });
</pre></td></tr></table></figure>

<p>上面的例子中增加了一个点击事件，并委托给了这个自定义标签元素里面的链接，这样，相当于为里面的a标签绑定了事件处理函数。</p>
<h2 id="模板">模板</h2>
<p>模板<code>template</code>中的元素会被转化为<code>DocumentFragment</code>对象，并且可以通过模板元素的<code>content</code>属性得到这个对象，然后通过<code>cloneNode()</code>方法创建新的实例。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">template</span> <span class="attribute">id</span>=<span class="value">"test-template"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span>&gt;</span>test<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">template</span>&gt;</span>

var t = document.getElementById('test-template');
document.body.appendChild(t.content.cloneNode());
</pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/08/02/Start-Using-X-Tag/" data-id="txgjjeg05z0xx6ps" class="article-share-link">分享到</a>
      
        <a href="http://yoursite.com/2014/08/02/Start-Using-X-Tag/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webcomponent/">webcomponent</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Custom-Elements" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/02/Custom-Elements/" class="article-date">
  <time datetime="2014-08-02T05:41:03.000Z" itemprop="datePublished">8月 2 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/02/Custom-Elements/">Custom Elements</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Custom Elements是<strong>Web Components</strong>中的一部分，通过它我们可以创建自定义的标签元素，而不用再使用大量的<code>div</code>了。明显自定义标签元素具有更好的可读性，但是它带来的好处不仅如此，同时还会有更好的封装和维护性。首先不妨看一下比较正式的正式：</p>
<blockquote>
<p>Custom elements are new types of DOM elements that can be defined by authors. Unlike decorators, which are stateless and ephemeral, custom elements can encapsulate state and provide script interfaces.</p>
</blockquote>
<h1 id="基本用法">基本用法</h1>
<h2 id="注册">注册</h2>
<p>在使用自定义元素之前，我们要通过Javascript进行元素的注册：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">var</span> XFoo = document.registerElement(<span class="string">'x-foo'</span>, {
  prototype: <span class="built_in">Object</span>.create(HTMLElement.prototype)
});
</pre></td></tr></table></figure><br>可以看到，自定义元素的注册主要是通过<code>registerElement</code>这个方法完成的，第一个参数是自定义元素的名字，第二个参数可以用来描述元素的原型。这里继承的是HTMLElement。且需要注意的是，自定义标签元素的名字必须有<code>-</code>，如<code>x-foo</code>，否则的话就不是一个合法的自定义标签。<br>如果我们想要对自定义元素进行扩展，我们直接操作prototype就好了，比如新加两个属性，<code>foo</code>和<code>bar</code>：<br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">var</span> XFoo = document.registerElement(<span class="string">'x-foo'</span>, {
  prototype: <span class="built_in">Object</span>.create(HTMLElement.prototype, {
    bar: {
      get: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> <span class="keyword">return</span> <span class="number">5</span>; }
    },
    foo: {
      value: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        alert(<span class="string">'foo() called'</span>);
      }
    }
  })
});
</pre></td></tr></table></figure><br>或者是分开来写：<br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">var</span> XFooProto = <span class="built_in">Object</span>.create(HTMLElement.prototype);
XFooProto.foo = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  alert(<span class="string">'foo() called'</span>);
};
<span class="built_in">Object</span>.defineProperty(XFooProto, <span class="string">"bar"</span>, {value: <span class="number">5</span>});
<span class="keyword">var</span> XFoo = document.registerElement(<span class="string">'x-foo'</span>, {prototype: XFooProto});
</pre></td></tr></table></figure><br>除了添加属性和方法之外，我们还可以指定不同的生命周期回调，这些回调会在自定义元素的不同阶段被调用：<br>1. <strong>createdCallback</strong>: 在元素创建的时候被调用<br>2. <strong>attachedCallback：</strong>在元素被插入到文档中的时候被调用<br>3. <strong>detachedCallback</strong>： 在元素从文档中被移除的时候被调用<br>4. <strong>attributeChangedCallback(attrName, oldVal, newVal)</strong>： 在元素的属性发生变化时被调用<br>因此，我们可以覆盖这些回调，比如：<br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> proto = <span class="built_in">Object</span>.create(HTMLElement.prototype);

XFooProto.createdCallback = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">this</span>.innerHTML = <span class="string">"&lt;b&gt;I'm an x-foo-with-markup!&lt;/b&gt;"</span>;
};

<span class="keyword">var</span> XFoo = document.registerElement(<span class="string">'x-foo'</span>, {prototype: proto});
</pre></td></tr></table></figure>

<p>这样，<code>x-foo</code>标签里面就有了内容。</p>
<h2 id="使用">使用</h2>
<p>注册了自己的标签元素之后，我们就可以使用了。创建一个新的自定义元素有两种方式：<br>    1.我们可以在HTML中直接进行声明；<br>    2.我们也可以在Javascript中动态的创建。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">// 直接声明</span>
<span class="subst">&lt;</span>x<span class="attribute">-foo</span><span class="subst">&gt;&lt;</span>/x<span class="attribute">-foo</span><span class="subst">&gt;</span>

<span class="comment">// 通过Javascript创建</span>
<span class="built_in">var</span> xFoo <span class="subst">=</span> document<span class="built_in">.</span>createElement(<span class="string">'x-foo'</span>);
document<span class="built_in">.</span>body<span class="built_in">.</span>appendChild(<span class="literal">new</span> xFoo());
</pre></td></tr></table></figure><br>除了直接创建我们的自定义标签，还可以在html原有的标签之上进行扩展，如：<br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">// 直接声明</span>
&lt;button <span class="keyword">is</span>=<span class="string">"mega-button"</span>&gt;

<span class="comment">// 通过Javascript创建</span>
<span class="keyword">var</span> megaButton = document.createElement(<span class="string">'button'</span>, <span class="string">'mega-button'</span>);
document.body.appendChild(<span class="keyword">new</span> megaButton());
</pre></td></tr></table></figure>

<h1 id="使用Shadow_DOM进行封装">使用Shadow DOM进行封装</h1>
<p>为了把自定义标签的灵活可读和Shadow DOM的良好封装结合起来，我们可以在createdCallback中加入Shadow DOM的有关代码：</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">template</span> <span class="attribute">id</span>=<span class="value">"sdtemplate"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css">
    <span class="tag">p</span> <span class="rules">{ <span class="rule"><span class="attribute">color</span>:<span class="value"> orange</span></span>; <span class="rule">}</span></span>
  </span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
  <span class="tag">&lt;<span class="title">p</span>&gt;</span>I'm in Shadow DOM. My markup was stamped from a &lt;template&gt;.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">template</span>&gt;</span>

<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
<span class="keyword">var</span> proto = <span class="built_in">Object</span>.create(HTMLElement.prototype, {
  createdCallback: {
    value: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">var</span> t = document.querySelector(<span class="string">'#sdtemplate'</span>);
      <span class="keyword">var</span> clone = document.importNode(t.content, <span class="literal">true</span>);
      <span class="keyword">this</span>.createShadowRoot().appendChild(clone);
    }
  }
});
document.registerElement(<span class="string">'x-foo-from-template'</span>, {prototype: proto});
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure><br>我们做了这么几件事：</p>
<ol>
<li>注册了一个新的元素： <code>x-foo-from-template</code></li>
<li>在元素创建时，会寻找页面中的一个<code>template</code>标签元素</li>
<li>创建一个<code>ShadowRoot</code>，并且把template元素的内容放到里面</li>
<li>Shadow DOM中的元素会以特定的样式渲染，这里就是将文字的颜色变为橘色</li>
</ol>
<p>也就是说，每当我们创建一个<code>x-foo-from-template</code>自定义标签元素时，里面都会带有一个Shadow DOM。如果这个标签元素实现了特定的功能，并且可以复用，那这个标签就是一个web组件，而且我们把这个组件的细节很好的封装到了Shadow DOM里面。</p>
<p>最后，如果一个自定义标签在还没有被注册就已经被声明了，那么这个元素就处于<strong>unresolved</strong>状态。这种状态也可以通过css的伪类<code>:unresolved</code>来进行查询。<br>此外，<code>document.registerElment</code>方法已经被Chrome 31+完全支持。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/08/02/Custom-Elements/" data-id="tavbagyru450sl9c" class="article-share-link">分享到</a>
      
        <a href="http://yoursite.com/2014/08/02/Custom-Elements/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webcomponent/">webcomponent</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Shadow-DOM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/02/Shadow-DOM/" class="article-date">
  <time datetime="2014-08-02T02:50:34.000Z" itemprop="datePublished">8月 2 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/02/Shadow-DOM/">Shadow DOM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是Web_Component">什么是Web Component</h1>
<p><strong>Web Component</strong> 是web平台开发新的一组特性，开发人员可以通过声明式、可组合的方式创建自己的应用。事实上，Web Component解决的问题就是如今的开发中，组件难以复用，或者构造起来比较复杂，封装不够彻底，内容和形式无法分离，以及大量不同的UI框架的实现方式千差万别，给维护和切换过程都带来不小的阻力。而Web Component则是以一种未来标准化的姿态来解决这些问题，通过使用它，既能够减少复杂程度，又能有效的实现组件的封装和复用。</p>
<p>下面我们就来看一下Web Component中对于组件封装的关键技术： <strong>Shadow DOM</strong>。文中示例来自<a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/" target="_blank" rel="external">Shadow DOM 101</a>。</p>
<h1 id="一个名片的例子">一个名片的例子</h1>
<p>在没有使用Web Component之前，组件封装所面临的问题就是封装的不彻底，具体来说就是对某一个组件设置的样式，添加的脚本以及设置的id值等等都潜在的对当前文档中的其他组件构成潜在的污染，也就是可能会产生名字重叠等意料之外的影响。加入我们要制作一个如下图效果的名片：<br><img src="/image/bob.png" alt=""></p>
<p>面对这样一个需求，我们很有可能会写出如下的代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css">
<span class="class">.outer</span> <span class="rules">{
  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">2</span>px solid brown</span></span>;
  <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">1</span>em</span></span>;
  <span class="rule"><span class="attribute">background</span>:<span class="value"> red</span></span>;
  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">20</span>pt</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">12</span>em</span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">7</span>em</span></span>;
  <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
<span class="rule">}</span></span>
<span class="class">.boilerplate</span> <span class="rules">{
  <span class="rule"><span class="attribute">color</span>:<span class="value"> white</span></span>;
  <span class="rule"><span class="attribute">font-family</span>:<span class="value"> sans-serif</span></span>;
  <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0.5</span>em</span></span>;
<span class="rule">}</span></span>
<span class="class">.name</span> <span class="rules">{
  <span class="rule"><span class="attribute">color</span>:<span class="value"> black</span></span>;
  <span class="rule"><span class="attribute">background</span>:<span class="value"> white</span></span>;
  <span class="rule"><span class="attribute">font-family</span>:<span class="value"> <span class="string">"Marker Felt"</span>, cursive</span></span>;
  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">45</span>pt</span></span>;
  <span class="rule"><span class="attribute">padding-top</span>:<span class="value"> <span class="number">0.2</span>em</span></span>;
<span class="rule">}</span></span>
</span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"outer"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"boilerplate"</span>&gt;</span>
    Hi! My name is
  <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"name"</span>&gt;</span>
    Bob
  <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>

<p>然而，这是一个封装不彻底的实现，接下来，我们使用Shadow DOM来解决这个问题。</p>
<h2 id="第一步，隐藏展现的细节">第一步，隐藏展现的细节</h2>
<p>如果仅仅从语义的角度考虑，我们可能会简化为下面的div:</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>&lt;<span class="keyword">div</span> <span class="property">id</span>=<span class="string">"nameTag"</span>&gt;Bob&lt;/<span class="keyword">div</span>&gt;
</pre></td></tr></table></figure><br>然后，我们再将用于展示的一些样式以及div添加到一个<code>template</code>标签中，最后看起来是这样：</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"nameTag"</span>&gt;</span>Bob<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">template</span> <span class="attribute">id</span>=<span class="value">"nameTagTemplate"</span>&gt;</span>
<span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css">
<span class="class">.outer</span> <span class="rules">{
  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">2</span>px solid brown</span></span>;

  <span class="rule">… <span class="attribute">same as above …

</span></span></span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"outer"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"boilerplate"</span>&gt;</span>
    Hi! My name is
  <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"name"</span>&gt;</span>
    Bob
  <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">template</span>&gt;</span>
</pre></td></tr></table></figure><br>这时，由于template元素并不会被渲染，被渲染的元素只是Bob而已。然而，我们却可以通过Javascript访问它。</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
	<span class="keyword">var</span> shadow = document.querySelector(<span class="string">'#nameTag'</span>).createShadowRoot();
	<span class="keyword">var</span> template = document.querySelector(<span class="string">'#nameTagTemplate'</span>);
	shadow.appendChild(template.content.cloneNode());
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure><br>这段代码的作用是填充一个Shadow root元素。这时，文档中显示的元素依然是Bob，这并不代表新添加的DOM元素不存在，只是它们被封装到了Shadow DOM中，所以外面看起来像是没有一样。打个比方，就像是同一个人处在两个不同的时空空间中。</p>
<h2 id="第二步，将内容和展现隔离开">第二步，将内容和展现隔离开</h2>
<p>通过上一步，我们已经把有关呈现的细节隐藏到另一个次元：Shadow DOM中了，但是，内容还是没有和展现很好的隔离开。对于这个例子来说，内容就是名片中的人名：Bob，它出现在了两个地方，一个是对外暴露的nameTag里面，我们可以从外部看到它；另外一个就是在模板中的名字div中。尽管看来这没有什么，但是如果内容是特别长的一段字符，或者是比较复杂的大型元素，这两个同步起来就不那么容易了。<br>事实上，我们可以通过<code>&lt;content&gt;&lt;/content&gt;</code>标签来声明它，这样一来，当外面的nametag被渲染的时候，其中的内容就会被插入到该标签中。如果我们想要改变其中的内容，只用一句话就行了，比如：</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">document</span>.querySelector(<span class="string">'#nameTag'</span>).textContent = <span class="string">'Shellie'</span>;
</pre></td></tr></table></figure><br>这样一来，我们就达成了内容和展现相互分离的目的：内容在document中，而展现在Shadow DOM中。</p>
<h2 id="第三步，改变样式和内容">第三步，改变样式和内容</h2>
<p>假如我们需要改变这个名片的样式的话，其实document中的元素我们丝毫不用动，而只需改变shadow DOM中的样式即可。比如我们修改为：</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">template</span> <span class="attribute">id</span>=<span class="value">"nameTagTemplate"</span>&gt;</span>
<span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css">
<span class="class">.outer</span> <span class="rules">{
  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">2</span>px solid pink</span></span>;
  <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">1</span>em</span></span>;
  <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">url(anotherbg.jpg)</span></span></span>;
  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">20</span>pt</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">12</span>em</span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">7</span>em</span></span>;
  <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
  <span class="rule"><span class="attribute">font-family</span>:<span class="value"> sans-serif</span></span>;
  <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> bold</span></span>;
<span class="rule">}</span></span>
<span class="class">.name</span> <span class="rules">{
  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">45</span>pt</span></span>;
  <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> normal</span></span>;
  <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">0.8</span>em</span></span>;
  <span class="rule"><span class="attribute">padding-top</span>:<span class="value"> <span class="number">0.2</span>em</span></span>;
<span class="rule">}</span></span>
</span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"outer"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"name"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">content</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  大家好，我的名字叫
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">template</span>&gt;</span>
</pre></td></tr></table></figure><br>这个名片真正的内容没有变，但是通过修改Shadow DOM，名片的背景发生了变化，前面的提示语也进行了更改。</p>
<p>对应的，如果我们想要改变内容，我们也无需知道关于样式的更多细节，而仅仅去更新document中对应nameTag元素的值就行了，就是这么简单。<br>总之，封装给我们带来的灵活性是，改变样式的时候无需知道内容的结构和细节，改变内容的时候也可以丝毫不知道样式采用什么结构。</p>
<h2 id="高级注入">高级注入</h2>
<p>前面我们已经使用<code>content</code>标签实现了内容的插入，如果我们想要更加精确的控制插入的内容，我们还可以对内容进行查询。比如，document中的内容是：</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>&lt;<span class="keyword">div</span> <span class="property">id</span>=<span class="string">"nameTag"</span>&gt;
  &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"first"</span>&gt;Bob&lt;/<span class="keyword">div</span>&gt;
  &lt;<span class="keyword">div</span>&gt;B. Love&lt;/<span class="keyword">div</span>&gt;
  &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"email"</span>&gt;bob@&lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</pre></td></tr></table></figure><br>对应的Shadow DOM是：</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"background: purple; padding: 1em;"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"color: red;"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">content</span> <span class="attribute">select</span>=<span class="value">".first"</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"color: yellow;"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">content</span> <span class="attribute">select</span>=<span class="value">"div"</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"color: blue;"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">content</span> <span class="attribute">select</span>=<span class="value">".email"</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure><br>这里，我们通过<code>select</code>属性对内容进行了查询，所以这里的content不再是document中全部的内容，而是查询后的一小段。<br>需要注意的是，内容中的email部分匹配了第二个和第三个content标签，但是，它只会采用第二个的样式，原则就是先到先得，first come, first serve.<br>最后，如果有些内容在Shadow DOM中没有找到匹配的值，那么它们就不会被渲染，也就是说，不会被展示出来，但是在document中使用javascript还是能访问到。既然不会被渲染，我们为什么还要写它呢？很显然，如果浏览器支持Shadow DOM，那么展现的就是Shadow DOM中的样式，如果不支持的话，展现的就是DOM中原有的样子，这种情况下，它就能被渲染出来了。<br>举个例子，我们在document中插入的是一个猫，但是在Shadow DOM中并没有插入它，而是另画了一只老虎。如果浏览器支持Shadow DOM，我们看到的就是一只老虎；而如果不支持，我们看到的就是一只猫。</p>
<p>最后的最后需要说的是，Shadow DOM在Chrome 35+是支持的，有图为例：<img src="/image/shadow-chrome.png" alt=""><br>这是Chrome Dev Tool中看到的，Shadow DOM元素已经被标出来了，如果我们展开来，看到的就是前面定义的样式：<img src="/image/shadow-chrome2.png" alt=""><br>而如果我们使用Javascript进行访问DOM,却不会访问到Shadow DOM:<img src="/image/shadow-chrome3.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/08/02/Shadow-DOM/" data-id="7jzels0l2b4xffxe" class="article-share-link">分享到</a>
      
        <a href="http://yoursite.com/2014/08/02/Shadow-DOM/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webcomponent/">webcomponent</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/02/hello-world/" class="article-date">
  <time datetime="2014-08-02T01:17:20.000Z" itemprop="datePublished">8月 2 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/02/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/tommy351/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2>
<h3 id="Create_a_new_post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ hexo new <span class="string">"My New Post"</span>
</pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ hexo server
</pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ hexo generate
</pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ hexo deploy
</pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/08/02/hello-world/" data-id="ef6wx5maui69jubb" class="article-share-link">分享到</a>
      
        <a href="http://yoursite.com/2014/08/02/hello-world/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/framework/">framework</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webcomponent/">webcomponent</a><span class="tag-list-count">5</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08">August 2014</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/08/11/【译】：为什么Web-Components还不适合于生产环境/">【译】：为什么Web Components还不适合于生产环境</a>
          </li>
        
          <li>
            <a href="/2014/08/11/【译】：创建自己的AngularJS应用----Scope和Digest/">【译】：创建自己的AngularJS应用 -- Scope和Digest</a>
          </li>
        
          <li>
            <a href="/2014/08/09/【译】：Throne-of-JS会议华山论剑之Javascript富应用/">【译】：Throne of JS会议华山论剑之Javascript富应用</a>
          </li>
        
          <li>
            <a href="/2014/08/03/Polymer-Getting-Started/">Polymer Getting Started</a>
          </li>
        
          <li>
            <a href="/2014/08/02/Start-Using-X-Tag/">Start Using X-Tag</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 cubika<br>
      Powered by <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape+</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'cubika';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>



<script src="/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>